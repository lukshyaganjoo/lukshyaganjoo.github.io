<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> why gym rats love ford-fulkerson | lukshya ganjoo </title> <meta name="author" content="lukshya ganjoo"> <meta name="description" content="what most people associate with the passage of water and time; a nightmarish combinatorial optimization problem for those in cs."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://lukshyaganjoo.github.io/blog/2024/fulkerson/"> <script src="/assets/js/theme.js?a5ca4084d3b81624bcfa01156dae2b8e"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.min.js"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "why gym rats love ford-fulkerson",
            "description": "what most people associate with the passage of water and time; a nightmarish combinatorial optimization problem for those in cs.",
            "published": "August 01, 2024",
            "authors": [
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> lukshya ganjoo </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">mosaic </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>why gym rats love ford-fulkerson</h1> <p>what most people associate with the passage of water and time; a nightmarish combinatorial optimization problem for those in cs.</p> </d-title> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#background-and-definitions">background and definitions</a> </div> <div> <a href="#the-problem">the problem</a> </div> <div> <a href="#the-solution-and-where-ford-and-fulkerson-come-in">the solution and where ford and fulkerson come in</a> </div> <div> <a href="#the-proof">the proof</a> </div> </nav> </d-contents> <p>In any standard algorithms class, there’s going to be an entire section of the course dedicated to what computer scientists refer to as “flow”. Besides being creatively named, it is also quite powerful in solving a variety of problems. For the purposes of motivation, I will go over some background, one of the more important network flow algorithms, and an application of this algorithm in the context of proving a seemingly unnatural equivalence.</p> <h2 id="background-and-definitions">background and definitions</h2> <ul> <li>a <strong>flow network</strong> is a directed graph \(G = (V, E)\) with a capacity function \(c : E \rightarrow \mathbb{R}^+\) and a source \(s \in V\) and a sink \(t \in V\).</li> <li>in the context of this definition, a <strong>flow</strong> moves units of water from the source \(s\) to the sink \(t\) in the graph \(G\). water can only be created from the source \(s\) and can only disappear at the sink \(t\).</li> <li>every edge \(e = (u, v) \in E\) has a capacity \(c(e)\) and the flow on a given edge \(e\), has to be less than or equal to the capacity of that given edge, i.e. \(0 \leq f(e) \leq c(e)\). (note here that based on these constraints, edges can’t have negative flow).</li> <li>for every vertex \(u \in V \setminus \\{s, t\\}\), the total flow entering the vertex \(u\) must be equal to the total flow leaving the vertex \(u\), i.e. \(\sum \limits_{v : e = (v, u) \in E} f(e) = \sum \limits_{u : e = (u, t) \in E} f(e)\).</li> <li>the value of a flow is defined as the net flow leaving the vertex \(s\) or equivalently the flow entering the vertex \(t\) (note this equivalence exists because of the conservation constraint we’ve defined above).</li> </ul> <h2 id="the-problem">the problem</h2> <ul> <li>given a flow network \(G = (V, E)\) with a capacity function \(c : E \rightarrow \mathbb{R}^+\) and a source \(s \in V\) and a sink \(t \in V\), it isn’t unereasonable to try and find the maximum flow that can travel through the network. this is a somewhat interesting question to ask because the naive idea of simply sending as much flow as you can on a given edge doesn’t really work out.</li> <li>consider the following flow network <img src="math-images/network1.png" alt="flow network"> </li> <li>the naive idea of finding a path from \(s\) to \(t\) and sending as much flow as possible on the edges given by that path doesn’t quite work. Consider the following path from \(s\) to \(t\) given by <img src="math-images/network2.png" alt="flow network"> </li> <li>since the minimimum edge capacity on the given path is 20 units of flow, we send 20 units of flow from \(s\) to \(t\) on the given path, and given that all the edges have the same capacity, there is no redirection happening here, where we send exactly 20 units from \(s\) to \(t\) as shown below <img src="math-images/network3.png" alt="flow network"> </li> </ul> <h2 id="the-solution-and-where-ford-and-fulkerson-come-in">the solution and where ford and fulkerson come in</h2> <ul> <li>we introduce a new concept called a <strong>residual graph</strong>. the residual graph of a graph \(G\) is defined as a graph \(\mathcal{R} = (V, E)\), where it has the exact same vertices and edges as the original graph, but differs from the original graph with regards to the capacities along each of the edges.</li> <li>if the original graph has an edge \((u, v)\) with capacity \(c\), and the flow sends along \(f_{u, v}\) along the given edge, we do the following <ul> <li>we include the edge \((u, v)\) in \(\mathcal{R}\) with capacity \(c - f_{u, v}\) as long as \(c - f_{u, v} &gt; 0\).</li> <li>we include the edge \((v, u)\) in \(\mathcal{R}\) with capacity \(f_{u, v}\) as long as \(f_{u, v} &gt; 0\).</li> </ul> </li> <li> <h3 id="the-algorithm-ford-and-fulkerson">the algorithm (ford and fulkerson)</h3> <ul> <li>while (\(\texttt{true}\)) <ul> <li>run \(\texttt{BFS}\) on \(\mathcal{R}\) starting from \(s\).</li> <li>record the predecessors to find an \(s-t\) path.</li> <li>if you can’t reach \(t\), then \(\texttt{break}\).</li> <li>iterate through the path and find the minimum residual capacity edge \(c\).</li> <li>add \(c\) to the flow on the path (on every edge in the path).</li> <li>update the residual graph \(\mathcal{R}\).</li> </ul> </li> <li> <h2 id="runtime">runtime:</h2> <ul> <li>\(\mathcal{O}(\vert E \vert \cdot f)\) where \(f\) is the maximum flow.</li> </ul> </li> </ul> </li> <li>we define an <strong>\((s, t)\)-cut</strong> for a graph \(G\) to be a split of vertices into two sets \((S, T)\) where \(S \subseteq V\) and \(T \subseteq V\) such that \(s \in S\) and \(t \in T\) and every other vertex in \(V\) is in one of \(S\) or \(T\). more formally, to be a cut, the following requirements need to be satisfied <ul> <li> \[S \cup T = V\] </li> <li> \[S \cap T = \varphi\] </li> <li> \[s \in S, t \in T\] </li> </ul> </li> <li> <p>the <strong>capacity</strong> of a cut \(C(S, T)\) denoted \(c(S, T)\) is defined as the sum of the capacities of the edges \((u, v)\) with \(u \in S\) and \(v \in T\), i.e.</p> \[c(S, T) = \sum_{u \in S} \sum_{v \in T} c(u, v)\] </li> <li>this definition of capacity is somewhat intuitive and in fact it suggests that we can define the flow of a cut in a similar manner.</li> <li> <p>given a cut \(C(S, T)\), with capacity \(c(S, T)\) and a flow \(f\), the <strong>flow</strong> of a cut \(C(S, T)\) is defined as the flow going from \(S\) to \(T\) minus the flow going from \(T\) to \(S\), i.e.</p> \[f(S, T) = \sum_{u \in S} \sum_{v \in T} f(u, v) - \sum_{u \in S} \sum_{v \in T} f(v, u)\] </li> </ul> <p>we finally stop the dilly-dallying and get to the main point of this post, the max-flow min-cut theorem.</p> <blockquote> <p>max-flow min-cut theorem</p> <p>Let \((\mathcal{G}, s, t, c)\) be a flow network, \(C(S, T)\) be an \(s-t\) cut, and \(f\) be a flow in \(\mathcal{G}\), then the following are equivalent:</p> <ul> <li>\(f\) is a maximum flow in \(\mathcal{G}\).</li> <li>\(\mathcal{G}_f\) contains no augmenting paths.</li> <li>there exists a cut \(C(S, T)\) such that \(c(S, T) = \text{val}(f)\).</li> </ul> </blockquote> <h2 id="the-proof">the proof</h2> <blockquote> <p>Lemma 1</p> <p>Let \((\mathcal{G}, s, t, c)\) be a flow network, \(C(S, T)\) be an \(s-t\) cut, and \(f\) be a flow in \(\mathcal{G}\), then:</p> \[f(S, T) \leq c(S, T)\] </blockquote> <p><strong>proof:</strong> For every edge \((u, v)\) by a consequence of the capacity constraint, we know that \(f(u, v) \leq c(u, v)\). Therefore, we can ascertain</p> <p style="overflow-x:auto"> $$ \begin{align*} f(S, T) &amp;= \sum_{u \in S} \sum_{v \in T} f(u, v) - \sum_{u \in S} \sum_{v \in T} f(v, u) &amp;&amp; \text{definition of flow} \\ &amp;\leq \sum_{u \in S} \sum_{v \in T} f(u, v) &amp;&amp;\text{non-negativity of a flow} \\ &amp;\leq \sum_{u \in S} \sum_{v \in T} c(u, v) &amp;&amp;\text{capacity constraint} \\ &amp;= c(S, T) &amp;&amp;\text{definition of capacity} \end{align*} $$ </p> <p>The larger consequence of this lemma is that for <strong>any cut</strong> you choose in the flow network, the flow going through \(C(S, T)\) is always bounded by its capacity.</p> <blockquote> <p>Lemma 2</p> <p>Let \((\mathcal{G}, s, t, c)\) be a flow network, \(C(S, T)\) be an \(s-t\) cut, and \(f\) be a flow in \(\mathcal{G}\), with \(v \in T\), then:</p> \[f(S, T) = f(S \cup \{v\}, T \setminus \{v\})\] </blockquote> <p><strong>proof:</strong> Let \(C(S, T)\) be any \(s-t\) cut and \(v\) an element in \(T\). Remove \(v\) from \(T\) and place it in \(S\). Let us now evaluate the flow of the new cut (call it \(C'(S', T')\)) where \(S' = S \cup \{v\}\) and \(T' = T \setminus \{v\}\).</p> <p>For the sake of notational convenience, we define the following sets</p> <p style="overflow-x:auto"> $$ \textsf{In}(v) = \{(u, v) \in E \mid u \in V\} \quad \text{and} \quad \textsf{Out}(v) = \{(v, w) \in E \mid w \in V\} $$ </p> <p>Intuitively, \(\textsf{In}(v)\) is the set of edges going into \(v\) and \(\textsf{Out}(v)\) is the set of edges going out of \(v\). We know that from the conservation of flow</p> \[\sum \limits_{(u, v) \in \textsf{In}(v)} f(u, v) = \sum \limits_{(v, w) \in \textsf{Out}(v)} f(v, w)\] <p>We now partition \(\textsf{In}(v)\) and \(\textsf{Out}(v)\) based on where the end-points of the edges in the set fall as follows</p> <p style="overflow-x:auto"> $$ \begin{align*} \textsf{In}_{S}(v) &amp;= \big\{(u, v) \in E \mid u \in S\big\} \\ \textsf{In}_{T}(v) &amp;= \big\{(u, v) \in E \mid u \in T\big\} \\ \textsf{Out}_{S}(v) &amp;= \big\{(v, w) \in E \mid w \in S\big\} \\ \textsf{Out}_{T}(v) &amp;= \big\{(v, w) \in E \mid w \in T\big\} \end{align*} $$ </p> <p>Finally let us evaluate the flow of this new cut. Moving \(v\) into \(S\) result in losing \(v\)’s contribution in the original cut capacity but also in gaining the contribution of the edges going out of \(v\), and therefore:</p> <p style="overflow-x:auto"> $$ \begin{align*} f(S', T') &amp;= f(S, T) - \sum \limits_{(u, v) \in \textsf{In}_{S}(v)} f(u, v) - \sum \limits_{(u, v) \in \textsf{In}_{T}(v)} f(u, v) \\ &amp;+ \sum \limits_{(v, w) \in \textsf{Out}_{S}(v)} f(v, w) + \sum \limits_{(v, w) \in \textsf{Out}_{T}(v)} f(v, w) \\ &amp;= f(S, T) - \sum \limits_{(u, v) \in \textsf{In}(v)} f(u, v) + \sum \limits_{(v, w) \in \textsf{Out}(v)} f(v, w) &amp;&amp;\text{since } \textsf{In}_{S}(v) \cup \textsf{In}_{T}(v) = \textsf{In}(v) \\ &amp;= f(S, T) &amp;&amp;\text{by conservation of flow} \end{align*} $$ </p> <blockquote> <p>Lemma 3</p> <p>Let \((\mathcal{G}, s, t, c)\) be a flow network, \(C(S, T)\) be an \(s-t\) cut, and \(f\) be a flow in \(\mathcal{G}\), then:</p> \[f(S, T) = \text{val}(f)\] </blockquote> <p><strong>proof:</strong> consider applying lemma 2 to the following cut \(C(S, T)\) where \(S = \{s\}\) and \(T = V \setminus \{s\}\), then:</p> \[f(\{s\}, V \setminus \{s\}) = f(\{s\} \cup S', V \setminus (\{s\} \cup S')) = f(S', T')\] <p>Essentially this implies that the flow of <strong>any cut</strong> is equal to the flow of the cut \(C(S, T)\) where \(S = \{s\}\) and \(T = V \setminus \{s\}\). How nice is that!! You may ask why is this nice? Well evaluating the flow of \(C(S, T)\) is much easier than evaluating the flow of any other cut. This is because the flow of \(C(S, T)\) is simply the flow leaving the source and this is the flow of the network :)</p> <p style="overflow-x:auto"> $$ \begin{align*} \text{val}(f) &amp;= \sum_{(u, v) \in E} f(u, v) \\ &amp;= f(\{s\}, V \setminus \{s\}) = f(S, T) &amp;&amp;\text{by lemma 2} \end{align*} $$ </p> <blockquote> <p>Corollary 1</p> <p>Let \((\mathcal{G}, s, t, c)\) be a flow network, \(C(S, T)\) be an \(s-t\) cut, and \(f\) be a flow in \(\mathcal{G}\), then:</p> \[\text{val}(f) \leq c(S, T)\] </blockquote> <p>now FINALLY, we can proceed with the proof of the max-flow min-cut theorem. we want to show that the 3 points of the theorem are equivalent. in the same vain,</p> <ul> <li>\(1 \implies 2:\) let \(f\) be a max flow and suppose that \(\mathcal{G}_f\) still has an augmenting path \(\mathcal{P}\). then we can increase the flow of \(f\) simply by augmenting \(f\) along \(\mathcal{P}\), which contradicts the assumption that \(f\) is a max flow. therefore \(G_f\) has no augmenting paths and \(f\) is a max flow.</li> <li> <p>\(2 \implies 3:\) suppose that \(\mathcal{G}_f\) has no augmenting paths. consider the cut \(C(S, T)\) such that \(c(S, T) = \text{val}(f)\). let \(S\) denote the set of vertices reachable from \(s\). if there is an augmenting \(s, t\) path from \(s\) to a vertex \(v\), then \(v \in S\). Since there are no augmenting paths, \(t \notin S\). let \(T = V \setminus S\) and therefore \(t \in T\). This implies that \(C(S, T)\) is a valid \(s-t\) cut. We now proceed with evaluating the flow across \(C(S, T)\).</p> <p>Consider an edge \((u, v)\) crossing the cut, i.e. \(u \in S\) and \(v \in T\). By definition \(c_f(u, v)\) denotes the capacity along the edge \((u, v)\) in the residual graph \(\mathcal{G}_f\). As a consequence of the terminating condition of \(\tt{ford-fulkerson}\) we have that \(c_f(u, v) = 0\) (otherwise there would have been an augmenting \(s, v\) path and \(v\) would be reachable from \(s\).)</p> <p>if \((u, v)\) is an edge of \(\mathcal{G}\) (the original graph), then since \(c_f(u, v) = 0\), by definition \(c(u, v) - f(u, v) = 0\) and therefore \(f(u, v) = c(u, v)\). if \((u, v)\) is not an edge of \(\mathcal{G}\) (it was added by the residual graph), then \(f(v, u) = 0\). this gives us that</p> <p style="overflow-x:auto"> $$ \begin{align*} \text{val}(f) &amp;= f(S, T) &amp;&amp;\text{lemma 3} \\ &amp;= \sum \limits_{u \in S} \sum \limits_{v \in T} f(u, v) - \sum \limits_{u \in S} \sum \limits_{v \in T} f(v, u) \\ &amp;= \sum \limits_{u \in S} \sum \limits_{v \in T} f(u, v) &amp;&amp;\text{since } f(v, u) = 0 \\ &amp;= \sum \limits_{u \in S} \sum \limits_{v \in T} c(u, v) &amp;&amp;\text{since } f(u, v) = c(u, v) \\ &amp;= c(S, T) \end{align*} $$ </p> </li> <li>\(3 \implies 1:\) let \(C(S, T)\) be a cut with capacity \(c(S, T) = \text{val}(f)\) and let \(f'\) be the maximum flow in \(\mathcal{G}\), i.e. \(\text{val}(f) \leq \text{val}(f')\). Since \(\text{val}(f) = c(S, T)\), we have that \(c(S, T) \leq \text{val}(f')\). By corollary 1, we have that \(\text{val}(f') \leq c(S, T)\) and therefore \(\text{val}(f) = c(S, T) = \text{val}(f')\). This implies that \(f\) is a max flow and we’re done :)</li> </ul> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/2018-12-22-distill.bib"></d-bibliography> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 lukshya ganjoo. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>